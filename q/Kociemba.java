package q;
import c.*;

import java.util.ListIterator;

/* this creates an int representation based on the Kociemba subset, just like the above subsets
 * the (kernel of the) Kociemba coordinate is generated by <U, R2, D>, or can be considered to be all CO & EO oriented,
 * with all midlayer edges on the midlayer. I relied on Kociemba's definition of the midlayer slice. */

public class Kociemba implements Coordinate {
    private Coordinate co;
    private Coordinate eo;
    private Coordinate udslice;
    private MultiCoordinate multicoord;
    private static String NAME;
    static {
        NAME = "Kociemba";
    }
    
    public Kociemba(Cube cube) {
        co = new CO(cube);
        eo = new EO(cube);
        udslice = new UDSlice(cube);
        multicoord = new MultiCoordinate(new Coordinate[]{co, eo, udslice});
    }
    public Kociemba() {
        co = new CO();
        eo = new EO();
        udslice = new UDSlice();
        multicoord = new MultiCoordinate(new Coordinate[]{co, eo, udslice});
    }
    public void set(Cube cube) {
        co = new CO(cube);
        eo = new EO(cube);
        udslice = new UDSlice(cube);
        multicoord = new MultiCoordinate(new Coordinate[]{co, eo, udslice});
    }
    public void move(Scramble scr) {
        ListIterator<Integer> iter = scr.getIterator();
        while(iter.hasNext()) {
            move(iter.next());
        }
    }
    
    public int value(Cube cube) {return multicoord.value(cube);}
    public int value() {return multicoord.value();}
    public void move(int move) {multicoord.move(move);}
    public String name() {return NAME;}
    public int size() {return multicoord.size();}
}
